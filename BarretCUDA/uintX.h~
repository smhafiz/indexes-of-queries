// This file was generated by BarretCUDA v0.1 
// 
// BarretCUDA is a fast(ish) CUDA implementation of sparse matrix
// multiplication modulo a multi-precision prime.
// 
// Copyright (C) 2016, Ryan Henry and Syed Mahbub Hafiz
// 
// 
// BarretCUDA is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// BarretCUDA is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with BarretCUDA.  If not, see <http://www.gnu.org/licenses/>.

#ifndef __UINT_96_H
#define __UINT_96_H
#include "uint.h"

#ifndef __UINTX__
#define __UINTX__
    typedef uint96 uintX;
#endif

static inline uint96 make_uint96(const uint w0x, const uint w0y, const uint w0z)
{
    uint96 res;

    uint * _res = (uint *)&res;
    _res[0]= w0x;				// res.w0.x= w0x
    _res[1]= w0y;				// res.w0.y= w0y
    _res[2]= w0z;				// res.w0.z= w0z

    return res;
}

static inline NTL::ZZ to_ZZ(const uint96 & n)
{
    return to_ZZ<uint96>(n);
}

static inline NTL::ZZ_p to_ZZ_p(const uint96 & n)
{
    return NTL::to_ZZ_p(to_ZZ<uint96>(n));
}

static inline uint96 to_uint96(const NTL::ZZ & n)
{
    return to_uint<uint96>(n);
}

__device__ __forceinline__ void normalize(uint2X<uint96> & a, const uint2X<uint96> & s)
{
    uint * _a = (uint *)&a;
    const uint * _s = (uint *)&s;
    asm("sub.cc.u32	 %0, %0, %6;\n\t"	// r0-= r6
	"subc.cc.u32	 %1, %1, %7;\n\t"	// r1-=( r7+c)
	"subc.cc.u32	 %2, %2, %8;\n\t"	// r2-=( r8+c)
	"subc.cc.u32	 %3, %3, %9;\n\t"	// r3-=( r9+c)
	"subc.cc.u32	 %4, %4,%10;\n\t"	// r4-=(r10+c)
	"subc.u32	 %5, %5,%11;\n\t"	// r5-=(r11+c)
	: "+r"(_a[0]), "+r"(_a[1]), "+r"(_a[2]), "+r"(_a[3]), "+r"(_a[4]), "+r"(_a[5])
	: "r"(_s[0]), "r"(_s[1]), "r"(_s[2]), "r"(_s[3]), "r"(_s[4]), "r"(_s[5]));
}

__device__ __forceinline__ void sub(uint2X<uint96> & a, const uintXp<uint96> & r)
{
    uint * _a = (uint *)&a;
    const uint * _r = (uint *)&r;
    asm("sub.cc.u32	 %0, %0, %4;\n\t"	// r0-= r4
	"subc.cc.u32	 %1, %1, %4;\n\t"	// r1-=( r4+c)
	"subc.cc.u32	 %2, %2, %5;\n\t"	// r2-=( r5+c)
	"subc.u32	 %3, %3, %5;\n\t"	// r3-=( r5+c)
	: "+r"(_a[0]), "+r"(_a[1]), "+r"(_a[2]), "+r"(_a[3])
	: "r"(_r[0]), "r"(_r[1]), "r"(_r[2]), "r"(_r[3]));
}

__device__ __forceinline__ uintXp<uint96> get_q(const uint2X<uint96> & a, const uint96 & mu)
{
    uint __attribute__((unused)) tmp;
    uintXp<uint96> q;
    uint * _q = (uint *)&q;
    uint * _a = (uint *)&a;
    uint * _mu = (uint *)&mu;
    asm("mul.hi.u32	 %2, %5, %9    ;\n\t"	// r2 =[ r5* r9].hi    (r-2 => r2)
	"mad.lo.cc.u32	 %2, %6, %9, %2;\n\t"	// r2+=[ r6* r9].lo    (r-2 => r2)
	"madc.lo.u32	 %3, %7, %9,  0;\n\t"	// r3 =[ r7* r9].lo+c  (r-1 => r3)
	"mad.lo.cc.u32	 %2, %5,%10, %2;\n\t"	// r2+=[ r5*r10].lo    (r-2 => r2)
	"madc.lo.cc.u32	 %3, %6,%10, %3;\n\t"	// r3+=[ r6*r10].lo+c  (r-1 => r3)
	"madc.lo.u32	 %0, %8, %9,  0;\n\t"	// r0 =[ r8* r9].lo+c
	"mad.lo.cc.u32	 %3, %5,%11, %3;\n\t"	// r3+=[ r5*r11].lo    (r-1 => r3)
	"madc.lo.cc.u32	 %0, %7,%10, %0;\n\t"	// r0+=[ r7*r10].lo+c
	"madc.lo.u32	 %1, %8,%10,  0;\n\t"	// r1 =[ r8*r10].lo+c
	"mad.hi.cc.u32	 %3, %6, %9, %3;\n\t"	// r3+=[ r6* r9].hi    (r-1 => r3)
	"madc.lo.cc.u32	 %0, %6,%11, %0;\n\t"	// r0+=[ r6*r11].lo+c
	"madc.lo.cc.u32	 %1, %7,%11, %1;\n\t"	// r1+=[ r7*r11].lo+c
	"madc.lo.u32	 %2, %8,%11,  0;\n\t"	// r2 =[ r8*r11].lo+c
	"mad.hi.cc.u32	 %3, %5,%10, %3;\n\t"	// r3+=[ r5*r10].hi    (r-1 => r3)
	"madc.hi.cc.u32	 %0, %7, %9, %0;\n\t"	// r0+=[ r7* r9].hi+c
	"madc.hi.cc.u32	 %1, %8, %9, %1;\n\t"	// r1+=[ r8* r9].hi+c
	"madc.hi.cc.u32	 %2, %8,%10, %2;\n\t"	// r2+=[ r8*r10].hi+c
	"madc.hi.u32	 %3, %8,%11,  0;\n\t"	// r3 =[ r8*r11].hi+c
	"mad.hi.cc.u32	 %0, %6,%10, %0;\n\t"	// r0+=[ r6*r10].hi  
	"madc.hi.cc.u32	 %1, %7,%10, %1;\n\t"	// r1+=[ r7*r10].hi+c
	"madc.hi.cc.u32	 %2, %7,%11, %2;\n\t"	// r2+=[ r7*r11].hi+c
	"addc.cc.u32	 %3, %3,  0    ;\n\t"	// r3+= c
	"addc.u32	 %4,  0,  0    ;\n\t"	// r4 = c
	"mad.hi.cc.u32	 %0, %5,%11, %0;\n\t"	// r0+=[ r5*r11].hi  
	"madc.hi.cc.u32	 %1, %6,%11, %1;\n\t"	// r1+=[ r6*r11].hi+c
	"addc.cc.u32	 %2, %2,  0    ;\n\t"	// r2+= c
	"addc.cc.u32	 %3, %3,  0    ;\n\t"	// r3+= c
	"addc.u32	 %4, %4,  0    ;\n\t"	// r4+= c
	"add.cc.u32	 %0, %0, %5    ;\n\t"	// r0+= r5
	"addc.cc.u32	 %1, %1, %6    ;\n\t"	// r1+= r6+c
	"addc.cc.u32	 %2, %2, %7    ;\n\t"	// r2+= r7+c
	"addc.cc.u32	 %3, %3, %8    ;\n\t"	// r3+= r8+c
	"addc.u32	 %4, %4,  0    ;\n\t"	// r4+=c
	: "=r"(tmp), "=r"(_q[0]), "=r"(_q[1]), "=r"(_q[2]), "=r"(_q[3])
	: "r"(_a[2]), "r"(_a[3]), "r"(_a[4]), "r"(_a[5]), "r"(_mu[0]), "r"(_mu[1]), "r"(_mu[2]));
	printf("\nInside get q\nmu:\t\t\t%u\t%u\t%u\n",_mu[0],_mu[1],_mu[2]);
	printf("\nInside get q\na:\t\t\t%u\t%u\t%u\t%u\n",_a[2],_a[3],_a[4],_a[5]);

    return q;
}

__device__ __forceinline__ uintXp<uint96> get_r2(const uintXp<uint96> & q, const uint96 & modulus)
{
    uintXp<uint96> r;
    uint * _r = (uint *)&r;
    uint * _q = (uint *)&q;
    uint * _m = (uint *)&modulus;

    asm("mad.lo.u32	 %0, %4, %8,  0;\n\t"	// r0 =[ r4* r8].lo  
	"mad.lo.u32	 %1, %4, %9,  0;\n\t"	// r1 =[ r4* r9].lo  
	"mad.lo.cc.u32	 %1, %5, %8, %1;\n\t"	// r1+=[ r5* r8].lo  
	"madc.lo.u32	 %2, %4,%10, %2;\n\t"	// r2+=[ r4*r10].lo+c
	"mad.hi.cc.u32	 %1, %4, %8, %1;\n\t"	// r1+=[ r4* r8].hi  
	"madc.lo.cc.u32	 %2, %5, %9, %2;\n\t"	// r2+=[ r5* r9].lo+c
	"madc.lo.cc.u32	 %3, %5,%10, %3;\n\t"	// r3+=[ r5*r10].lo+c
	"mad.hi.cc.u32	 %2, %4, %9, %2;\n\t"	// r2+=[ r4* r9].hi  
	"madc.hi.cc.u32	 %3, %4,%10, %3;\n\t"	// r3+=[ r4*r10].hi+c
	"mad.lo.cc.u32	 %2, %6, %8, %2;\n\t"	// r2+=[ r6* r8].lo  
	"madc.lo.cc.u32	 %3, %6, %9, %3;\n\t"	// r3+=[ r6* r9].lo+c
	"mad.hi.cc.u32	 %2, %5, %8, %2;\n\t"	// r2+=[ r5* r8].hi  
	"madc.hi.cc.u32	 %3, %5, %9, %3;\n\t"	// r3+=[ r5* r9].hi+c
	"mad.lo.cc.u32	 %3, %7, %8, %3;\n\t"	// r3+=[ r7* r8].lo  
	"mad.hi.cc.u32	 %3, %6, %8, %3;\n\t"	// r3+=[ r6* r8].hi  
	: "=r"(_r[0]), "=r"(_r[1]), "=r"(_r[2]), "=r"(_r[3])
	: "r"(_q[0]), "r"(_q[1]), "r"(_q[2]), "r"(_q[3]), "r"(_m[0]), "r"(_m[1]), "r"(_m[2]));

    return r;
}
__device__ __forceinline__ void mad(uint2X<uint96> & a, uint & overflow, const uint96 & b, const uint96 & c)
{
    uint * _a = (uint *)&a;
    const uint * _b = (uint *)&b;
    const uint * _c = (uint *)&c;
    printf("\nBefore mad\na:\t\t\t%u\t%u\t%u\t%u\t%u\t%u\n",_a[0],_a[1],_a[2],_a[3],_a[4],_a[5]);
    asm("mad.lo.cc.u32	 %0, %7,%10, %0;\n\t"	// r0+=[ r7*r10].lo  
	"madc.hi.cc.u32	 %1, %7,%10, %1;\n\t"	// r1+=[ r7*r10].hi  
	"madc.lo.cc.u32	 %2, %9,%10, %2;\n\t"	// r2+=[ r9*r10].lo+c
	"madc.hi.cc.u32	 %3, %9,%10, %3;\n\t"	// r3+=[ r9*r10].hi+c
	"madc.lo.cc.u32	 %4, %9,%12, %4;\n\t"	// r4+=[ r9*r12].lo+c
	"madc.hi.cc.u32	 %5, %9,%12, %5;\n\t"	// r5+=[ r9*r12].hi+c
	"addc.u32	 %6, %6,  0    ;\n\t"	// r6+=c
	"mad.lo.cc.u32	 %1, %8,%10, %1;\n\t"	// r1+=[ r8*r10].lo  
	"madc.hi.cc.u32	 %2, %8,%10, %2;\n\t"	// r2+=[ r8*r10].hi  
	"madc.lo.cc.u32	 %3, %9,%11, %3;\n\t"	// r3+=[ r9*r11].lo+c
	"madc.hi.cc.u32	 %4, %9,%11, %4;\n\t"	// r4+=[ r9*r11].hi+c
	"addc.cc.u32	 %5, %5,  0    ;\n\t"	// r5+=c
	"addc.u32	 %6, %6,  0    ;\n\t"	// r6+=c
	"mad.lo.cc.u32	 %1, %7,%11, %1;\n\t"	// r1+=[ r7*r11].lo  
	"madc.hi.cc.u32	 %2, %7,%11, %2;\n\t"	// r2+=[ r7*r11].hi  
	"madc.lo.cc.u32	 %3, %8,%12, %3;\n\t"	// r3+=[ r8*r12].lo+c
	"madc.hi.cc.u32	 %4, %8,%12, %4;\n\t"	// r4+=[ r8*r12].hi+c
	"addc.cc.u32	 %5, %5,  0    ;\n\t"	// r5+=c
	"addc.u32	 %6, %6,  0    ;\n\t"	// r6+=c
	"mad.lo.cc.u32	 %2, %8,%11, %2;\n\t"	// r2+=[ r8*r11].lo  
	"madc.hi.cc.u32	 %3, %8,%11, %3;\n\t"	// r3+=[ r8*r11].hi  
	"addc.cc.u32	 %4, %4,  0    ;\n\t"	// r4+=c
	"addc.cc.u32	 %5, %5,  0    ;\n\t"	// r5+=c
	"addc.u32	 %6, %6,  0    ;\n\t"	// r6+=c
	"mad.lo.cc.u32	 %2, %7,%12, %2;\n\t"	// r2+=[ r7*r12].lo  
	"madc.hi.cc.u32	 %3, %7,%12, %3;\n\t"	// r3+=[ r7*r12].hi  
	"addc.cc.u32	 %4, %4,  0    ;\n\t"	// r4+=c
	"addc.cc.u32	 %5, %5,  0    ;\n\t"	// r5+=c
	"addc.u32	 %6, %6,  0    ;\n\t"	// r6+=c
	: "+r"(_a[0]), "+r"(_a[1]), "+r"(_a[2]), "+r"(_a[3]), "+r"(_a[4]), "+r"(_a[5]), "+r"(overflow)
	: "r"(_b[0]), "r"(_b[1]), "r"(_b[2]), "r"(_c[0]), "r"(_c[1]), "r"(_c[2]));
	printf("\nAfter mad\na:\t\t\t%u\t%u\t%u\t%u\t%u\t%u\n",_a[0],_a[1],_a[2],_a[3],_a[4],_a[5]);
	printf("b:\t\t\t%u\t%u\t%u\nc:\t\t\t%u\t%u\t%u\n",_b[0],_b[1],_b[2],_c[0],_c[1],_c[2]);
}

#endif

