// This file is part of BarretCUDA v0.1 
// 
// BarretCUDA is a fast(ish) CUDA implementation of sparse matrix
// multiplication modulo a multi-precision prime.
// 
// Copyright (C) 2016, Ryan Henry and Syed Mahbub Hafiz
// 
// 
// BarretCUDA is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// BarretCUDA is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with BarretCUDA.  If not, see <http://www.gnu.org/licenses/>.

#include <stdio.h>
#include <iostream>
#include <vector>
#include <stdint.h>
#include <stdlib.h>
#include <chrono>

#define BITS_PER_LIMB	(sizeof(uint) * 8)
#define BITS_IN(limbs)	((limbs) * BITS_PER_LIMB)

typedef unsigned int uint;

using namespace std;

static const char coords []  = { 'x', 'y', 'z', 'w' };

char * r0;
char * r1;
char * r2;
char * r3;

/// get_q

#define LO 			0
#define HI 			1

#define CARRY 			1
#define MUL			2
#define MADC 			3

#define CARRY_IN(i)		(state[i] |= CARRY)
#define MUL_IN(i)		(state[i] |= MUL)

#define IS_OCCUPIED(i)		(state[i] & MADC ? true : false)
#define DO_CARRY_OUT(i)		(state[i] & MUL ? true : false)
#define CARRY_OUT_FLAG(i)	(DO_CARRY_OUT(i) ? ".cc" : "")
#define CARRY_IN_FLAG(b)	(b ? "c" : "")
#define LO_OR_HI(p)		(p.first == HI ? ".hi" : ".lo")

#define GET_DEST_REG(i)  	(i < limbs-1 ? i+1 : i-limbs+1)//(i < limbs-1 ? limbs+i-1 : i-1)
#define GET_FIRST_REG(p)	(limbs+1+p.second)//(2*limbs-1+p.second)
#define GET_SECOND_REG(i,p)	(2*limbs+1+i-p.second-p.first)//(3*limbs-1+i-p.second-p.first)

/// end get_q

static void print_license()
{
    cout << "// This file was generated by BarretCUDA v0.1 \n" \
	    "// \n" \
	    "// BarretCUDA is a fast(ish) CUDA implementation of sparse matrix\n" \
	    "// multiplication modulo a multi-precision prime.\n" \
	    "// \n" \
	    "// Copyright (C) 2016, Ryan Henry and Syed Mahbub Hafiz\n" \
	    "// \n" \
	    "// \n" \
	    "// BarretCUDA is free software: you can redistribute it and/or modify\n" \
	    "// it under the terms of the GNU General Public License as published\n" \
	    "// by the Free Software Foundation, either version 3 of the License,\n" \
	    "// or (at your option) any later version.\n" \
	    "// \n" \
	    "// BarretCUDA is distributed in the hope that it will be useful,\n" \
	    "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" \
	    "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" \
	    "// GNU General Public License for more details.\n" \
	    "// \n" \
	    "// You should have received a copy of the GNU General Public License\n" \
	    "// along with BarretCUDA.  If not, see <http://www.gnu.org/licenses/>.\n\n";
}

static void print_uint(uint limbs)
{
    /// output the uintX struct
    cout << "struct uint" << BITS_IN(limbs) << "\n";
    cout << "{\n";
    int i;
    for (i = 0; i < limbs - 3; i += 4)
    {
	cout << "    uint128 w" << i << "; \t\t\t\t// limbs " << i << " to " << (i+3) << "\n";
    }
    int rem = BITS_IN(limbs % 4);
    if (rem) cout << "    uint" << rem << "  w" << i << "; \t\t\t\t// limbs " << i << " to " << (limbs - 1) << "\n";
    cout << "};\n\n";
}

static void print_to_ZZ(uint limbs)
{
    /// output to_ZZ (converts a uintX to a ZZ)
    cout << "static inline NTL::ZZ to_ZZ(const uint" << BITS_IN(limbs) <<  " & n)\n";
    cout << "{\n";
    cout << "    return to_ZZ<uint" << BITS_IN(limbs) << ">(n);\n";
    cout << "}\n\n";
}

static void print_make_uint(uint limbs)
{
    cout << "static inline uint" << BITS_IN(limbs) << " make_uint" << BITS_IN(limbs) << "(const uint w0x";
    for (int i = 1; i < limbs; i++)
    {
	sprintf(r0, "w%u%c", i/4, coords[i%4]);
	cout << ", const uint " << r0;
    }
    cout << ")\n{\n";
    cout << "    uint" << BITS_IN(limbs) << " res;\n\n";
    cout << "    uint * _res = (uint *)&res;\n";
    for (int i = 0; i < limbs; ++i)
    {
	sprintf(r0, "w%u%c", i/4, coords[i%4]);
	printf("    _res[%u]=%4s;\t\t\t\t// res.w%u.%c=%4s\n", i, r0, i/4, coords[i%4], r0);
	//cout << "    _res[" << i << "]=w" << i << ";\t\t\t\t\t// res.w" << (i/4) << "." << coords[i%4] << "=w"\n";
    }
    cout << "\n    return res;\n";
    cout << "}\n\n";
}

static void print_to_ZZ_p(uint limbs)
{
    /// output to_ZZ_p (converts a uintX to a ZZ_p)
    cout << "static inline NTL::ZZ_p to_ZZ_p(const uint" << BITS_IN(limbs) <<  " & n)\n";
    cout << "{\n";
    cout << "    return NTL::to_ZZ_p(to_ZZ<uint" << BITS_IN(limbs) << ">(n));\n";
    cout << "}\n\n";
}

static void print_to_uint(uint limbs)
{
    /// output to_uintX (converts a ZZ to a uintX)
    cout << "static inline uint" << BITS_IN(limbs) << " to_uint" << BITS_IN(limbs) << "(const NTL::ZZ & n)\n";
    cout << "{\n";
    cout << "    return to_uint<uint" << BITS_IN(limbs) << ">(n);\n";
    cout << "}\n\n";
}

static void print_normalize(uint limbs)
{
    cout << "__device__ __forceinline__ void normalize(uint2X<uint" << BITS_IN(limbs) << "> & a, const uint2X<uint" << BITS_IN(limbs) << "> & s)\n";
    cout << "{\n";
    cout << "    uint * _a = (uint *)&a;\n";
    cout << "    const uint * _s = (uint *)&s;\n";
    sprintf(r0, "%%%u", 0);
    sprintf(r2, "%%%u", 2 * limbs);
    printf("    asm(\"sub.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t// r0-=%3s\n", &(*r2='r'));
    for (int i = 1; i < 2 * limbs - 1; ++i)
    {
	sprintf(r0, "%%%u", i);
	sprintf(r2, "%%%u", 2 * limbs + i);
	printf("\t\"subc.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
	printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", 2 * limbs - 1);
    sprintf(r2, "%%%u", 4 * limbs - 1);
    printf("\t\"subc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    cout << "\t: \"+r\"(_a[0])";
    for (int i = 1; i < 2 * limbs; i++) cout << ", \"+r\"(_a[" << i << "])";
    cout << "\n\t: \"r\"(_s[0])";
    for (int i = 1; i < 2 * limbs; i++) cout << ", \"r\"(_s[" << i << "])";
    cout << ");\n";
    cout << "}\n\n";
}

static void print_sub(uint limbs)
{
    cout << "__device__ __forceinline__ void sub(uint2X<uint" << BITS_IN(limbs) << "> & a, const uintXp<uint" << BITS_IN(limbs) << "> & r)\n";
    cout << "{\n";
    cout << "    uint * _a = (uint *)&a;\n";
    cout << "    const uint * _r = (uint *)&r;\n";
    sprintf(r0, "%%%u", 0);
    sprintf(r2, "%%%u", limbs + 1);
    printf("    asm(\"sub.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t// r0-=%3s\n", &(*r2='r'));
    for (int i = 1; i < limbs; ++i)
    {
	sprintf(r0, "%%%u", i);
	sprintf(r2, "%%%u", limbs + i);
	printf("\t\"subc.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
	printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", limbs);
    sprintf(r2, "%%%u", 2 * limbs - 1);
    printf("\t\"subc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    cout << "\t: \"+r\"(_a[0])";
    for (int i = 1; i < limbs + 1; i++) cout << ", \"+r\"(_a[" << i << "])";
    cout << "\n\t: \"r\"(_r[0])";
    for (int i = 1; i < limbs + 1; i++) cout << ", \"r\"(_r[" << i << "])";
    cout << ");\n";
    cout << "}\n\n";
}

static void print_mad(uint limbs)
{
    vector< vector<int> > col(2 * limbs);
    for (int i = 0; i < limbs; ++i)
    {
	for (int j = limbs - 1; j >= 0; --j) col[i + j].push_back(i);
    }
    
    cout << "__device__ __forceinline__ void mad(uint2X<uint" << BITS_IN(limbs) << "> & a, uint & overflow, const uint" << BITS_IN(limbs) << " & b, const uint" << BITS_IN(limbs) << " & c)\n";
    cout << "{\n";
    cout << "    uint * _a = (uint *)&a;\n";
    cout << "    const uint * _b = (uint *)&b;\n";
    cout << "    const uint * _c = (uint *)&c;\n\n";
    cout << "    asm(";
    int curr = 0;
    while (curr < 2 * limbs)
    {
	while (col[curr].empty()) { ++curr; }
	bool carry = false;
	for (int i = curr; i < 2 * limbs; )
	{
	    if (col[i].empty())
	    {
		sprintf(r0, "%%%u", i);
		printf("\"addc.cc.u32\t%3s,%3s,  0    ;\\n\\t\"", r0, r0);
		printf("\t//%3s+=c\n\t", &(*r0='r'));
		i++;
	    }
	    else
	    {
		sprintf(r0, "%%%u", i);
		sprintf(r1, "%%%u", col[i].back() + 2 * limbs + 1);
		sprintf(r2, "%%%u", i - col[i].back() + 3 * limbs + 1);
		sprintf(r3, "%%%u", i+1);
		printf("\"mad%s.lo.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", (carry ? "c" : ""), r0, r1, r2, r0);
		printf("\t//%3s+=[%3s*%3s].lo%s\n\t", &(*r0='r'), &(*r1='r'), &(*r2='r'), (carry ? "+c" : "  "));
		printf("\"madc.hi.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", r3, &(*r1='%'), &(*r2='%'), r3);
		printf("\t//%3s+=[%3s*%3s].hi%s\n\t", &(*r3='r'), &(*r1='r'), &(*r2='r'), (carry ? "+c" : "  "));
		carry = true;
		col[i].pop_back();
		i += 2;
	    }
	}
	if (curr < 2 * limbs)
	{
	    sprintf(r0, "%%%u", 2 * limbs);
	    printf("\"addc.u32\t%3s,%3s,  0    ;\\n\\t\"", r0, r0);
	    printf("\t//%3s+=c\n\t", &(*r0='r'));
	}
    }
    cout << ": ";
    for (int i = 0; i < 2 * limbs; ++i) cout << "\"+r\"(_a[" << i << "]), ";
    cout << "\"+r\"(overflow)\n\t: \"r\"(_b[0])";
    for (int i = 1; i < limbs; ++i) cout << ", \"r\"(_b[" << i << "])";
    for (int i = 0; i < limbs; ++i) cout << ", \"r\"(_c[" << i << "])";
    cout << ");\n";
    cout << "}\n\n";
}

void propagate_q(int i, int limbs, bool c, int * state, vector< vector< pair<int,int> > > & pairs)
{
    bool cc = DO_CARRY_OUT(i);
    sprintf(r0, "%%%u", GET_DEST_REG(i));
    //if (!c) cout << "\n";
    if (pairs[i].empty())
    {
	printf("\t\"add%s%s.u32\t%3s,%3s,  0    ;\\n\\t\"", CARRY_IN_FLAG(c), CARRY_OUT_FLAG(i), r0, (IS_OCCUPIED(i) ? r0 : "  0"));
	sprintf(r0, "r%u", GET_DEST_REG(i));
	printf("\t//%3s%s= c", r0, (IS_OCCUPIED(i) ? "+" : " ")); 
	CARRY_IN(i);
    }
    else
    {
	auto p = pairs[i].back();
	pairs[i].pop_back();
	sprintf(r1, "%%%u", GET_FIRST_REG(p));
	sprintf(r2, "%%%u", GET_SECOND_REG(i,p));
	printf("\t\"mad%s%s%s.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", CARRY_IN_FLAG(c), LO_OR_HI(p), CARRY_OUT_FLAG(i), r0, r1, r2, (IS_OCCUPIED(i) ? r0 : "  0"));
	sprintf(r0, "r%u", GET_DEST_REG(i));
	sprintf(r1, "r%u", GET_FIRST_REG(p));
	sprintf(r2, "r%u", GET_SECOND_REG(i,p));
	printf("\t//%3s%s=[%3s*%3s]%s%s", r0, (IS_OCCUPIED(i) ? "+" : " "), r1, r2, LO_OR_HI(p), (c ? "+c" : "  "));
	MUL_IN(i);
    }
    if (i < limbs - 1) cout << "  (r" << (i - limbs + 1) << " => r" << GET_DEST_REG(limbs + i) << ")";
    cout << "\n";
    if (cc && i < 2 * limbs - 1) propagate_q(i + 1,limbs, true, state, pairs);
}

inline void print_get_q(int limbs)
{
    int * state = new int[2 * limbs];
    vector< vector< pair<int,int> > > pairs(2 * limbs);

    for (int i = 0; i < 2 * limbs; ++i)
    {
	for (int j = 0; j <= i; j++)
	{
	    if (i - j < limbs - 1 && j < limbs)
	    {
		if (i == 0 && j == 0) continue;
		pairs[i].push_back(make_pair(LO, j));
		pairs[i+1].push_back(make_pair(HI, j));
	    }
	}
    }

    cout << "__device__ __forceinline__ uintXp<uint" << BITS_IN(limbs-1) << "> get_q(const uint2X<uint" << BITS_IN(limbs-1) << "> & a, const uint" << BITS_IN(limbs-1) << " & mu)\n";
    cout << "{\n";
    cout << "    uint __attribute__((unused)) tmp;\n";
    cout << "    uintXp<uint" << BITS_IN(limbs-1) << "> q;\n";
    cout << "    uint * _q = (uint *)&q;\n";
    cout << "    uint * _a = (uint *)&a;\n";
    cout << "    uint * _mu = (uint *)&mu;\n";

    auto p = make_pair(1,0);
    sprintf(r0, "%%%u", GET_DEST_REG(limbs+1));
    sprintf(r1, "%%%u", GET_FIRST_REG(p));
    sprintf(r2, "%%%u", GET_SECOND_REG(1,p));
    printf("    asm(\"mul.hi.u32\t%3s,%3s,%3s    ;\\n\\t\"", r0, r1, r2);
    sprintf(r0, "r%u", GET_DEST_REG(limbs+1));
    sprintf(r1, "r%u", GET_FIRST_REG(p));
    sprintf(r2, "r%u", GET_SECOND_REG(1,p));
    printf("\t//%3s =[%3s*%3s].hi  ", r0, r1, r2);
    cout << "  (r" << (2-limbs) << " => r" << GET_DEST_REG(limbs+1) <<  ")\n";
    MUL_IN(1);

    for (int i = 0; i < 2 * limbs; i++)
    {
	while (!pairs[i].empty())
	{
	    propagate_q(i, limbs, false, state, pairs);
	}
    }

    // handle the implicit 1-word
    sprintf(r0, "%%%u", GET_DEST_REG(limbs));
    sprintf(r1, "%%%u", 2 * limbs - 1);
    printf("\t\"add.cc.u32\t%3s,%3s,%3s    ;\\n\\t\"",r0,r0,r1);
    sprintf(r0, "r%u", GET_DEST_REG(limbs));
    sprintf(r1, "r%u", 2 * limbs - 1);
    printf("\t//%3s+=%3s\n", r0, r1);
    for (int i = limbs; i < 2 * limbs - 2; i++)
    {
	sprintf(r0, "%%%u", GET_DEST_REG(i+1));
	sprintf(r1, "%%%u", i + limbs);
	printf("\t\"addc.cc.u32\t%3s,%3s,%3s    ;\\n\\t\"",r0,r0,r1);
	sprintf(r0, "r%u", GET_DEST_REG(i+1));
	sprintf(r1, "r%u", i + limbs);
	printf("\t//%3s+=%3s+c\n", r0, r1);
    }
    sprintf(r0, "%%%u", GET_DEST_REG(2 * limbs - 1));
    sprintf(r1, "%%%u", 3 * limbs - 2);
    printf("\t\"addc.u32\t%3s,%3s,%3s    ;\\n\\t\"",r0,r0,r1);
    sprintf(r0, "r%u", GET_DEST_REG(2 * limbs - 1));
    sprintf(r1, "r%u", 3 * limbs - 2);
    printf("\t//%3s+=%3s+c\n", r0, r1);

//    sprintf(r0, "%%%u", GET_DEST_REG(2 * limbs - 1));
//    sprintf(r1, "%%%u", 3 * limbs - 2);
//    printf("  //\t\"addc.cc.u32\t%3s,%3s,%3s    ;\\n\\t\"\t// propagate overflow?\n",r0,r0,r1);
//    sprintf(r0, "r%u", GET_DEST_REG(2 * limbs - 1));
//    sprintf(r1, "r%u", 3 * limbs - 2);
//    printf("  //\t\"addc.u32\t %%0,  0,  0    ;\\n\\t\"\t// overflow?\n");

    cout << "\t: \"=r\"(tmp)";
    for (int i = 0; i < limbs; i++) printf(", \"=r\"(_q[%u])", i);
    cout << "\n\t: \"r\"(_a[0])";
    for (int i = 1; i < limbs; i++) printf(", \"r\"(_a[%u])", i);
    for (int i = 0; i < limbs-1; i++) printf(", \"r\"(_mu[%u])", i);
    cout << ");\n\n";
    cout << "    return q;\n";
    cout << "}\n\n";

    delete [] state;
}

void propagate_r(int i, int limbs, bool c, int * state, vector< vector< pair<int,int> > > & pairs)
{
    bool cc = DO_CARRY_OUT(i);
    sprintf(r0, "%%%u", i);
    //if (!c) cout << "\n";
    auto p = pairs[i].back();
    pairs[i].pop_back();
    sprintf(r1, "%%%u", GET_FIRST_REG(p)-1);
    sprintf(r2, "%%%u", GET_SECOND_REG(i,p)-1);
    printf("\"mad%s%s%s.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", CARRY_IN_FLAG(c), LO_OR_HI(p), CARRY_OUT_FLAG(i), r0, r1, r2, (IS_OCCUPIED(i) ? r0 : "  0"));
    sprintf(r0, "r%u", i);
    sprintf(r1, "r%u", GET_FIRST_REG(p)-1);
    sprintf(r2, "r%u", GET_SECOND_REG(i,p)-1);
    printf("\t//%3s%s=[%3s*%3s]%s%s\n\t", r0, (IS_OCCUPIED(i) ? "+" : " "), r1, r2, LO_OR_HI(p), (c ? "+c" : "  "));
    MUL_IN(i);
    if (cc && i < limbs - 1) propagate_r(i + 1, limbs, true, state, pairs);
}

inline void print_get_r2(uint limbs)
{
    int * state = new int[limbs+1];
    vector< vector< pair<int,int> > > pairs(limbs+1);

    for (int i = 0; i < limbs; ++i)
    {
	for (int j = 0; j <= limbs-i; j++)
	{
	    pairs[i+j].push_back(make_pair(LO, j));
	    if ((i+j) < limbs) pairs[i+j+1].push_back(make_pair(HI, j));
	}
    }

    cout << "__device__ __forceinline__ uintXp<uint" << BITS_IN(limbs) << "> get_r2(const uintXp<uint" << BITS_IN(limbs) << "> & q, const uint" << BITS_IN(limbs) << " & modulus)\n";
    cout << "{\n";
    cout << "    uintXp<uint" << BITS_IN(limbs) << "> r;\n";
    cout << "    uint * _r = (uint *)&r;\n";
    cout << "    uint * _q = (uint *)&q;\n";
    cout << "    uint * _m = (uint *)&modulus;\n\n";

    cout << "    asm(";    
    for (int i = 0; i <= limbs; i++)
    {
	while (!pairs[i].empty())
	{
	    propagate_r(i, limbs+1, false, state, pairs);
	}
    }
    cout << ": \"=r\"(_r[0])";
    for (int i = 1; i <= limbs; ++i) cout << ", \"=r\"(_r[" << i << "])";
    cout << "\n\t: \"r\"(_q[0])";
    for (int i = 1; i <= limbs; ++i) cout << ", \"r\"(_q[" << i << "])";
    for (int i = 0; i < limbs; ++i) cout << ", \"r\"(_m[" << i << "])";
    cout << ");\n\n";

    cout << "    return r;\n";
    cout << "}\n";

    delete [] state;
}

int main(int argc, char ** argv)
{
    char * endptr = NULL;

    uint limbs = (argc > 1) ? strtoul(argv[1], &endptr, 10) : 0;

    if (argc != 2 || *endptr != '\0')
    {
    	cout << "Usage: " << argv[0] << " LIMBS > uintX.h\n\n";
    	return -1;
    }
    if (limbs < 3)
    {
    	cout << "Error: number of limbs must be at least 3\n\n";
    	return -1;
    }

    r0 = new char[8];
    r1 = new char[8];
    r2 = new char[8];
    r3 = new char[8];

    print_license();

    cout << "#ifndef __UINT_" << BITS_IN(limbs) << "_H\n";
    cout << "#define __UINT_" << BITS_IN(limbs) << "_H\n";
    cout << "#include \"uint.h\"\n\n";

    if (limbs > 4) print_uint(limbs);
    cout << "#ifndef __UINTX__\n";
    cout << "#define __UINTX__\n";
    cout << "    typedef uint" << BITS_IN(limbs) << " uintX;\n";
    cout << "#endif\n\n";

    print_make_uint(limbs);
    print_to_ZZ(limbs);
    print_to_ZZ_p(limbs);
    print_to_uint(limbs);

    print_normalize(limbs);
    print_sub(limbs);
    print_get_q(limbs+1);
    print_get_r2(limbs);

    print_mad(limbs);

    cout << "#endif\n\n";

    delete [] r0;
    delete [] r1;
    delete [] r2;
    delete [] r3;

    return 0;
}
