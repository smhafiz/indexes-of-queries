#include <NTL/ZZ.h>
#include <NTL/ZZ_p.h>
#include <stdint.h>
#include <iostream>

	#include <NTL/ZZ.h>
	NTL_CLIENT;

typedef uint4 uint128;
typedef uint3 uint96;
typedef uint2 uint64;
typedef uint uint32;

/*typedef uint4 uint128;
typedef uint2 uint64;
typedef uint3 uint96;*/
struct uint160 { uint128 word; uint overflow; };



template <typename T>
static inline ZZ to_ZZ(const T & a){
	return ZZFromBytes((const unsigned char *)&a, sizeof(T));
}
template <typename T>
static inline ZZ_p to_ZZ_p(const T & a){
	return to_ZZ_p(ZZFromBytes((const unsigned char *)&a, sizeof(T)));
}



static inline ZZ to_ZZ(const uint64 & a) { return to_ZZ<uint64>(a); }
static inline ZZ_p to_ZZ_p(const uint64 & a) { return to_ZZ_p<uint64>(a); }

/*
template <typename T>
static inline T to_uint(const ZZ & a)
{
	T res;
	BytesFromZZ((unsigned char *)&res, a, sizeof(T));
	return res;
}
static inline uint160 to_uint96(const ZZ & a) { return to_uint<uint96>(a); }
static inline ZZ to_ZZ(const uint128 & a) { return to_ZZ<uint128>(a); }
static inline ZZ_p to_ZZ_p(const uint128 & a) { return to_ZZ_p<uint128>(a); }
static inline uint128 to_uint128(const ZZ & a) { return to_uint<uint128>(a); }*/

__device__ __forceinline__ void mad(uint160 & a, const uint64 b, const uint64 c)
{
    asm("mad.lo.cc.u32  %0,%10,%12,%5; \n\t"
	"madc.lo.cc.u32 %1,%10,%13,%6; \n\t"
	"madc.lo.cc.u32 %2,%11,%13,%7; \n\t"
	"madc.hi.cc.u32 %3,%11,%13,%8; \n\t"
	"addc.u32       %4,%9, 0;    \n\t"
	"mad.hi.cc.u32  %1,%10,%12,%1; \n\t"
	"madc.hi.cc.u32 %2,%10,%13,%2; \n\t"
	"addc.cc.u32    %3,%3, 0;    \n\t"
	"addc.u32       %4,%4, 0;    \n\t"
	"mad.lo.cc.u32  %1,%11,%12,%1; \n\t"
	"madc.hi.cc.u32 %2,%11,%12,%2; \n\t"
	"addc.cc.u32    %3,%3, 0;    \n\t"
	"addc.u32       %4,%4, 0;    \n\t"
	: "=r"(a.word.x), "=r"(a.word.y), "=r"(a.word.z), "=r"(a.word.w), "=r"(a.overflow)
	: "r"(a.word.x), "r"(a.word.y), "r"(a.word.z), "r"(a.word.w), "r"(a.overflow)
          "r"(b.x), "r"(b.y), "r"(c.x), "r"(c.y));
}

__device__ __forceinline__ uint96 get_q(const uint128 a, const uint64 mu)
{
    uint96 q = make_uint3(0, 0, 0);

    asm("mul.hi.u32      %1,%3,%5   ;\n\t"  // (a0 * b0)_hi 	*11*

	"mad.lo.cc.u32   %1,%3,%6,%1;\n\t"  // (a0 * b1)_lo 	*11*
	"madc.hi.u32     %2,%3,%6, 0;\n\t"  // (a0 * b1)_hi 	!22!

	"mad.lo.cc.u32   %1,%4,%5,%1;\n\t"  // (a1 * b0)_lo 	*11*
	"madc.hi.cc.u32  %2,%4,%5,%2;\n\t"  // (a1 * b0)_hi 	!22!
	"madc.hi.u32     %0,%3,%7, 0;\n\t"  // (a0 * b2)_hi     <--0

	"mad.lo.cc.u32   %2,%3,%7,%2;\n\t"  // (a0 * b2)_lo 	!22!
	"madc.hi.cc.u32  %0,%4,%6,%0;\n\t"  // (a1 * b1)_hi
	"madc.hi.u32     %1,%4,%7, 0;\n\t"  // (a1 * b2)_hi

	"madc.lo.cc.u32  %2,%4,%6,%5;\n\t"  //			!22!
	"madc.lo.cc.u32  %0,%4,%7,%0;\n\t"  // (a1 * b2)_lo
	"addc.cc.u32     %1,%1,%7   ;\n\t"  // (a2 * b2)_lo
	"addc.u32        %2, 0, 0   ;\n\t"  // propagate carry  <--2

	"add.cc.u32      %0,%0,%6   ;\n\t"  // (a2 * b1)_lo
	"addc.cc.u32     %1,%1, 0   ;\n\t"  // propagate carry
	"addc.u32        %2,%2, 0   ;\n\t"  // propagate carry
	 : "=r"(q.x), "=r"(q.y), "=r"(q.z) 
	 : "r"(mu.x), "r"(mu.y), "r"(a.y), "r"(a.z), "r"(a.w));

    return q;
}

__device__ __forceinline__ uint96 get_r(const uint96 q, const uint64 modulus)
{
    uint96 r = make_uint3(0, 0, 0);
    asm("mul.lo.u32     %0,%3,%6;   \n\t" // r0 =(r3*r5).[31:0 ]
	"mul.hi.u32     %1,%3,%6;   \n\t" // r1 =(r3*r5).[63:32]
	"mad.lo.cc.u32  %1,%3,%7,%1;\n\t" // r1+=(r3*r6).[31:0 ], may carry-out
	"madc.hi.u32    %2,%3,%7, 0;\n\t" // r2 =(r3*r6).[63:32]+carry-in, no carry-out
	"mad.lo.cc.u32  %1,%4,%6,%1;\n\t" // r1+=(r4*r5).[31:0 ], may carry-out
	"madc.hi.cc.u32 %2,%4,%6,%2;\n\t" // r2+=(r4*r5).[63:32]+carry-in, may carry-out
	"mad.lo.u32     %2,%4,%7,%2;\n\t" // r2+=(r4*r6).[31:0 ], no carry-out
	"mad.lo.u32     %2,%5,%6,%2;\n\t"
	: "=r"(r.x), "=r"(r.y), "=r"(r.z)
	: "r"(q.x), "r"(q.y), "r"(q.z), "r"(modulus.x), "r"(modulus.y));

    return r;
}

__device__ __forceinline__ void sub_u96(uint128 & a, const uint96 r)
{
    asm("sub.cc.u32     %0,%3,%6;   \n\t" // r0-=r3, may borrow-out
	"subc.cc.u32    %1,%4,%7;   \n\t" // r1-=(r4+borrow-in), may borrow-out
	"subc.u32       %2,%5,%8;   \n\t" // r2-=(r5+borrow-in), no borrow-out
	: "=r"(a.x), "=r"(a.y), "=r"(a.z)
	: "r"(a.x), "r"(a.y), "r"(a.z),
	  "r"(r.x), "r"(r.y), "r"(r.z));
}

__device__ __forceinline__ void sub_u128(uint128 & a, const uint128 s)
{
    asm("sub.cc.u32     %0,%4,%8;   \n\t" // r0-=r3, may borrow-out
	"subc.cc.u32    %1,%5,%9;   \n\t" // r1-=(r4+borrow-in), may borrow-out
	"subc.cc.u32    %2,%6,%10;  \n\t" // r2-=(r5+borrow-in), may borrow-out
	"subc.u32       %3,%7,%11;  \n\t" // r2-=(r5+borrow-in), no borrow-out
	: "=r"(a.x), "=r"(a.y), "=r"(a.z), "=r"(a.w)
	: "r"(a.x), "r"(a.y), "r"(a.z), "r"(a.w),
          "r"(s.x), "r"(s.y), "r"(s.z), "r"(s.w));
}

__global__ void kernel(uint160 * a, const uint64 b, const uint64 c,
	const uint64 * modulus, const uint64 * mu, const uint128 * subtrahends)
{
    mad(*a, b, c);
    sub_u128(a->word, subtrahends[a->overflow]);
    uint96 q = get_q(a->word, *mu);
    uint96 r = get_r(q, *modulus);
    sub_u96(a->word, r);
}


int main(int argc, char **argv)
{
    const uint16_t u = 2;

    const uint16_t limbs = 2;
    const uint16_t bits_per_limb = 32;
    const uint16_t bits_per_word = limbs * bits_per_limb;
    const uint16_t bits_per_prod = 2 * bits_per_word;

    uint160 a = { make_uint4(0, 0, 0, 0), 0 };
    uint64 b = make_uint2(2995084201U, 2186485480U); // 9390883632773946281
    uint64 c = make_uint2(3273957355U, 3326371885U); // 14286658463682830315
    std::cout << "First operand\t"<< (to_ZZ(b)) << ", \nSecond Operand\t" << (to_ZZ(c))<<" \n";
    uint160 product = { make_uint4(1394416419, 2026265284, 1080393059, 1693392133), 0 }; // 134164347133630463830451404165848308515
    const uint64_t modulus = 18446744073709551557ULL;
    uint64 rem = make_uint2(713098817, 3152153338); // 13538395499400332865

    
    //ZZ test start
    ZZ modulus_zz = to_ZZ("18446744073709551557");
    ZZ mu_zz = power2_ZZ(bits_per_prod) / to_ZZ(modulus);
    const uint64 mu = make_uint2(conv<uint>(mu_zz), conv<uint>(mu_zz << bits_per_limb)); // actual mu is 2^bits_per_word greater than this!

    uint128 * subtrahends = (uint128 *) malloc(u * sizeof(uint128));
    for (int i = 0; i < u; ++i)
    {
	ZZ subtrahend = ((to_ZZ(i) << bits_per_prod) / modulus_zz) * modulus_zz;
	subtrahends[i].x = conv<uint>(subtrahend);
	subtrahends[i].y = conv<uint>(subtrahend / power2_ZZ(bits_per_limb));
	subtrahends[i].z = conv<uint>(subtrahend / power2_ZZ(2 * bits_per_limb));
	subtrahends[i].w = conv<uint>(subtrahend / power2_ZZ(3 * bits_per_limb));
    }

    ZZ b_zz = to_ZZ("9390883632773946281");
    ZZ c_zz = to_ZZ("14286658463682830315");
    ZZ a_zz = b_zz *c_zz;

    ZZ q1 = a_zz >> (limbs - 1) * bits_per_limb;
    ZZ q2 = q1 * mu_zz;
    ZZ q3 = q2 >> (limbs + 1) * bits_per_limb;

	cout << "\nZZ test start::\nmu: " << NumBits(mu_zz) << "\n";
	cout << "q1: " << NumBits(q1) << "\n";
	cout << "q2: " << NumBits(q2) << "\n";
	cout << "q3: " << NumBits(q3) << "\n\n";

	cout << "q.x : " << conv<uint>(q3) << "\n";
	cout << "q.y : " << conv<uint>(q3>>32) << "\n";
	cout << "q.z : " << conv<uint>(q3>>64) << "\n";

    ZZ r1;
    NTL::rem(r1, a_zz, power2_ZZ((limbs + 1) * bits_per_limb));
    ZZ r2;
    NTL::rem(r2, q3 * modulus_zz, power2_ZZ((limbs + 1) * bits_per_limb));

cout << "r.x : " << conv<uint>(r2) << "\n";
cout << "r.y : " << conv<uint>(r2>>32) << "\n";
cout << "r.z : " << conv<uint>(r2>>64) << "\n";

    ZZ r = r1 - r2;

    cout << "r before subtrahends: " << r << "\n";
    if (r < 0) r = r + power2_ZZ((limbs + 1) * bits_per_limb);
    while (r >= modulus_zz) r = r - modulus_zz;
    ZZ res;
    NTL::rem(res, a_zz, modulus_zz);
    cout << "r after subtrahends: " << r << "\n";
    cout << "res : " << res << "\nZZ test finished\n\n";

	//ZZ test finished
    const uint64 mu_c = make_uint2(59, 0); // actual mu is 2^64 greater than this!

    uint128 * subtrahends_c = (uint128 *) malloc(u * sizeof(uint128));
    subtrahends_c[0] = make_uint4(0, 0, 0, 0);
    subtrahends_c[1] = make_uint4(4294963815UL, 4294967295UL, 4294967295UL, 4294967295UL);

    uint160 * a_d;
    cudaMalloc((void**) & a_d, sizeof(uint160));
    cudaMemcpy(a_d, & a, sizeof(uint160), cudaMemcpyHostToDevice);

    uint64 * mu_d;
    cudaMalloc((void**) & mu_d, sizeof(uint64));
    cudaMemcpy(mu_d, & mu_c, sizeof(uint64), cudaMemcpyHostToDevice);

    uint64 * modulus_d;
    cudaMalloc((void**) & modulus_d, sizeof(uint64));
    cudaMemcpy(modulus_d, & modulus, sizeof(uint64), cudaMemcpyHostToDevice);

    uint128 * subtrahends_d;
    cudaMalloc((void**) & subtrahends_d, u * sizeof(uint128));
    cudaMemcpy(subtrahends_d, subtrahends_c, u * sizeof(uint128), cudaMemcpyHostToDevice);

    kernel<<<1,1>>>(a_d, b, c, modulus_d, mu_d, subtrahends_d);

    cudaMemcpy(& a, a_d, sizeof(uint160), cudaMemcpyDeviceToHost);

    std::cout << "GPU:: a.x :\t\t" << a.word.x << "\ta.y:\t\t"<< a.word.y << "\n";
    std::cout << "Real:reminder.x\t" << rem.x << "\t:reminder.y\t" << rem.y << "\n";
//    std::cout << "a.z : "<< a.word.z << "\t:reminder.z " << product.word.z << "\n";
//    std::cout << "a.w : "<< a.word.w << "\t:reminder.w " << product.word.w << "\n";

    cudaFree(a_d);
    cudaFree(mu_d);
    cudaFree(modulus_d);

    return 0;
}
